var documenterSearchIndex = {"docs":
[{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"CartesianOperators.jl provides two operator construction modes:\n\nAssembled sparse operators (G, H, Winv)\nMatrix-free kernels (dm!, dmT!, gradient!, divergence!, laplacian!)\n\nThe operators are built from:\n\nForward differences (D_p / dp!), Backward differences (D_m / dm!)\nForward averages (S_p), Backward averages (S_m / sm!)\nGeometry fields (A, B, Winv) from GeometricMoments\nVelocity fields for advection.","category":"section"},{"location":"operators/#Penguin-Compatible-Algebra","page":"Operators","title":"Penguin-Compatible Algebra","text":"For a state vector x = [xω; xγ] (bulk and interface DOFs) and flux vector q = [qω; qγ] (bulk and interface fluxes):\n\nGradient: Winv * (G*xω + H*xγ)\nDivergence: -(G' + H')*qω + H'*qγ\nLaplacian: -G' * Winv * (G*xω + H*xγ)\nScalar advection: centered (assembled + kernel), upwind (assembled + kernel) and MUSCL (kernel) with interface coupling K.\n\nConvection schemes:\n\nAssembled path: Centered(), Upwind1()\nKernel path: Centered(), Upwind1(), MUSCL(MC()), MUSCL(Minmod()), MUSCL(VanLeer())","category":"section"},{"location":"boundary-conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"CartesianOperators.jl supports box boundary conditions through BoxBC:\n\nNeumann(0) (default)\nPeriodic\nDirichlet(value)\n\nConstructors accept bc:\n\nopsA = assembled_ops(moments; bc=bc)\nopsK = kernel_ops(moments; bc=bc)","category":"section"},{"location":"boundary-conditions/#Default-BC","page":"Boundary Conditions","title":"Default BC","text":"If bc is not passed, all sides use Neumann(0).","category":"section"},{"location":"boundary-conditions/#Periodic-Convention","page":"Boundary Conditions","title":"Periodic Convention","text":"For a direction with dims[d] = n, the storage is endpoint-duplicated:\n\n1:(n-1) are physical periodic DOFs\nn duplicates index 1\n\nTherefore periodic wrap uses n-1, not n.\n\nThis implies:\n\nseam is 1 ↔ n-1\nrow/entry at index n is inactive for difference-like operators","category":"section"},{"location":"boundary-conditions/#Dirichlet-Handling","page":"Boundary Conditions","title":"Dirichlet Handling","text":"Dirichlet is imposed as a row constraint:\n\nKernel path: apply_dirichlet_rows!\nAssembled path: impose_dirichlet!\n\nThis keeps interface machinery (H, xγ) unchanged.","category":"section"},{"location":"boundary-conditions/#Hyperbolic/Convection-BC","page":"Boundary Conditions","title":"Hyperbolic/Convection BC","text":"Advection uses a separate boundary container:\n\nAdvBoxBC for hyperbolic inflow/outflow/periodic ghost states and advection stencil topology\n\nAvailable advection BCs:\n\nAdvOutflow (default)\nAdvInflow(value)\nAdvPeriodic\n\nAdvInflow(value) is meaningful for upwind-based advection:\n\nkernel: Upwind1() and MUSCL(...)\nassembled: Upwind1()\n\nCentered advection does not consume inflow ghost values.\n\nDiffusion-style Dirichlet row replacement is not applied automatically to convection.","category":"section"},{"location":"boundary-conditions/#Interior-vs-Exterior-Level-Set-Sign","page":"Boundary Conditions","title":"Interior vs Exterior Level Set Sign","text":"Interior object in box: ϕ = r - r0 (ϕ < 0 inside circle)\nExterior in box: ϕ = r0 - r (ϕ < 0 outside circle)\n\nFor exterior domains touching the box boundary, explicit box BC selection is essential.","category":"section"},{"location":"boundary-conditions/#Example","page":"Boundary Conditions","title":"Example","text":"using CartesianOperators\n\nbc_adv = AdvBoxBC(\n    (AdvPeriodic{Float64}(), AdvOutflow{Float64}()),\n    (AdvPeriodic{Float64}(), AdvOutflow{Float64}())\n)\n\nbc_adv isa AdvBoxBC","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Index","page":"API Reference","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#CartesianOperators.advection_diffusion!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector, KernelAdvectionDiffusionOps{N, T}, NTuple{N, var\"#s5\"} where var\"#s5\"<:(AbstractVector), NTuple{N, var\"#s4\"} where var\"#s4\"<:(AbstractVector), AbstractVector, AbstractVector, KernelWork, KernelWork}} where {N, T}","page":"API Reference","title":"CartesianOperators.advection_diffusion!","text":"advection_diffusion!(out, adops, uω, uγ, Tω, Tγ, ...; scheme=Centered())\n\nCompute κ*Δ(Tω,Tγ) + convection(uω,uγ,Tω,Tγ) in the sign convention used by laplacian! and convection!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CartesianOperators.build_convection_parts-Union{Tuple{T}, Tuple{N}, Tuple{AssembledConvectionOps{N, T}, NTuple{N, var\"#s30\"} where var\"#s30\"<:(AbstractVector), NTuple{N, var\"#s29\"} where var\"#s29\"<:(AbstractVector), AbstractVector, AbstractVector}} where {N, T}","page":"API Reference","title":"CartesianOperators.build_convection_parts","text":"build_convection_parts(cops, uω, uγ, Tω, Tγ)\n\nBuild per-dimension centered advection contributions (bulk and coupling) in assembled form. This uses periodic wrapping when requested by cops.bc_adv; otherwise stencil rows are inactive at the padded boundary.\n\n\n\n\n\n","category":"method"},{"location":"#CartesianOperators.jl","page":"Home","title":"CartesianOperators.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CartesianOperators\")","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"CartesianOperators.jl builds Cartesian cut-cell operators from CartesianGeometry.GeometricMoments with two modes:\n\nAssembled sparse operators (G, H, Winv)\nMatrix-free kernels (dm!, dmT!, gradient!, divergence!, laplacian!)\n\nThe package follows Penguin-compatible algebra. For a state vector x = [xω; xγ] (bulk and interface DOFs) and flux vector q = [qω; qγ] (bulk and interface fluxes):\n\nGradient: Winv * (G*xω + H*xγ)\nDivergence: -(G' + H')*qω + H'*qγ\nLaplacian: -G' * Winv * (G*xω + H*xγ)\nScalar advection: centered (assembled + kernel) and upwind/MUSCL (kernel) with interface coupling K.\n\nOperators are built from:\n\nForward differences (D_p / dp!), Backward differences (D_m / dm!)\nForward averages (S_p), Backward averages (S_m / sm!)\nGeometry fields (A, B, Winv) from GeometricMoments\nVelocity fields for advection.","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using CartesianGeometry\nusing CartesianOperators\n\nx = collect(range(0.0, 1.0; length=9))\ny = collect(range(0.0, 1.0; length=10))\nphi(x, y, _=0) = sqrt((x - 0.5)^2 + (y - 0.5)^2) - 0.25\n\nm = geometric_moments(phi, (x, y), Float64, zero; method=:implicitintegration)\n\nopsA = assembled_ops(m)\nopsK = kernel_ops(m)\nwork = KernelWork(opsK)\n\nNd = opsA.Nd\nN = length(opsA.dims)\n\nxω = randn(Nd)\nxγ = randn(Nd)\ng1 = zeros(N * Nd)\ng2 = zeros(N * Nd)\n\ngradient!(g1, opsA, xω, xγ)\ngradient!(g2, opsK, xω, xγ, work)\n\nmaximum(abs, g1 - g2)","category":"section"},{"location":"#Notes","page":"Home","title":"Notes","text":"Node-padded layout is used: Nd = prod(node_counts).\nPhysical cells are at indices 1:(node_counts[d]-1) in each dimension.\nLast layer per dimension is padded.","category":"section"},{"location":"#Main-Sections","page":"Home","title":"Main Sections","text":"Boundary Conditions\nAPI Reference","category":"section"}]
}
