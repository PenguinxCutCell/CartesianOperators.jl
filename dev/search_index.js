var documenterSearchIndex = {"docs":
[{"location":"diffusion/#Diffusion-Operators","page":"Diffusion Operators","title":"Diffusion Operators","text":"Elliptic operators -∇·(D∇) are built from the core algebra of gradient/divergence/laplacian.","category":"section"},{"location":"diffusion/#Implemented-algebra-(exact-signs)","page":"Diffusion Operators","title":"Implemented algebra (exact signs)","text":"For vectors xω, xγ ∈ ℝ^{Nd} and stacked fluxes qω, qγ ∈ ℝ^{NNd}:\n\nnabla_h(xωxγ) = W^-1left(Gx^omega + Hx^gammaright)\n\noperatornamediv_h(q^omegaq^gamma) = -(G^top + H^top)q^omega + H^top q^gamma\n\nDelta_h(x^omegax^gamma) = -G^top W^-1left(Gx^omega + Hx^gammaright)\n\nNotes:\n\nWith Dirichlet in BoxBC, laplacian_matrix(ops, ...) and kernel laplacian! use ghost-state elimination (boundary values injected into the effective xω state).\nExplicit Dirichlet affine RHS can be built with dirichlet_rhs / dirichlet_rhs!.\nStrong row replacement is optional and explicit (impose_dirichlet!), not default.","category":"section"},{"location":"diffusion/#Constructors","page":"Diffusion Operators","title":"Constructors","text":"assembled_ops(m; bc=nothing) -> AssembledOps\nkernel_ops(m; bc=nothing) -> KernelOps\nbuild_GHW(m; bc=nothing) -> (G, H, Winv)\n\nbc=nothing means default Neumann(0) on all box sides.","category":"section"},{"location":"diffusion/#Assembled-API","page":"Diffusion Operators","title":"Assembled API","text":"gradient!(g, ops::AssembledOps, xω, xγ)\ndivergence!(y, ops::AssembledOps, qω, qγ)\nlaplacian!(y, ops::AssembledOps, xω, xγ)\ngradient_matrix(ops, xω, xγ)\ndivergence_matrix(ops, qω, qγ)\nlaplacian_matrix(ops, xω, xγ)\ndirichlet_rhs(ops) / dirichlet_rhs!(rhs, ops)\n\nAccessors:\n\nG(ops)\nH(ops)\nWinv(ops) / W!(ops)\nIγ(ops)","category":"section"},{"location":"diffusion/#Kernel-API","page":"Diffusion Operators","title":"Kernel API","text":"KernelWork(ops::KernelOps)\ngradient!(g, ops::KernelOps, xω, xγ, work)\ndivergence!(y, ops::KernelOps, qω, qγ, work)\nlaplacian!(y, ops::KernelOps, xω, xγ, work)\ndirichlet_rhs!(rhs, ops::KernelOps, work)\n\nLow-level directional kernels:\n\ndm!, dmT!, dp!, sm!","category":"section"},{"location":"diffusion/#Pseudo-inverse-rule-for-W","page":"Diffusion Operators","title":"Pseudo-inverse rule for W","text":"invW[d][i] is built with:\n\n0 if W[d][i] is non-finite or zero\ninv(W[d][i]) otherwise\n\nThis prevents NaN propagation in matrix-free paths.","category":"section"},{"location":"diffusion/#Example","page":"Diffusion Operators","title":"Example","text":"opsA = assembled_ops(m)\nopsK = kernel_ops(m)\nwork = KernelWork(opsK)\n\nNd = opsA.Nd\nN = length(opsA.dims)\n\nxω = randn(Nd)\nxγ = randn(Nd)\nqω = randn(N * Nd)\nqγ = randn(N * Nd)\n\ng = zeros(N * Nd)\ny = zeros(Nd)\n\ngradient!(g, opsK, xω, xγ, work)\ndivergence!(y, opsK, qω, qγ, work)\nlaplacian!(y, opsK, xω, xγ, work)","category":"section"},{"location":"constraints/#Interface-Constraints","page":"Interface Constraints","title":"Interface Constraints","text":"This package provides reusable linear constraint operators in the form:\n\nCω*xω + Cγ*xγ = r\n\nand diphasic extensions.\n\nThe interface weight is the geometric moment field interface_measure, exposed as Iγ.","category":"section"},{"location":"constraints/#Implemented-equations-(exact-signs)","page":"Interface Constraints","title":"Implemented equations (exact signs)","text":"Define the interface flux contraction:\n\nPhi(x^omegax^gamma) = H^top W^-1(Gx^omega + Hx^gamma)\n\nand the diagonal interface weight I_\\gamma = \\operatorname{diag}(\\texttt{interface\\_measure}).\n\nRobin:\n\nR_mathrmRobin\n= (a odot I_gamma odot x^gamma)\n+ (b odot Phi(x^omegax^gamma))\n- (I_gamma odot g)\n\nFlux jump (phase 2 minus phase 1):\n\nR_mathrmjump\n= b_2 odot Phi_2(x_2^omegax_2^gamma)\n- b_1 odot Phi_1(x_1^omegax_1^gamma)\n- I_gamma odot g\n\nScalar jump:\n\nR_mathrmscalar\n= I_gamma odot (alpha_2 x_2^gamma - alpha_1 x_1^gamma - g)\n\nThese are the signs used in both assembled matrices and matrix-free residual functions.","category":"section"},{"location":"constraints/#Constraint-types","page":"Interface Constraints","title":"Constraint types","text":"RobinConstraint\nFluxJumpConstraint\nScalarJumpConstraint\n\nAll support scalar or vector coefficient inputs via convenience constructors.","category":"section"},{"location":"constraints/#Assembled-builders","page":"Interface Constraints","title":"Assembled builders","text":"robin_constraint_matrices, robin_constraint_row\nfluxjump_constraint_matrices, fluxjump_constraint_row\nscalarjump_constraint_matrices, scalarjump_constraint_row\n\n*_row returns a sparse row-operator for stacked unknowns.","category":"section"},{"location":"constraints/#Matrix-free-residuals","page":"Interface Constraints","title":"Matrix-free residuals","text":"robin_residual!\nfluxjump_residual!\nscalarjump_residual!\nhelper: div_gamma! (kernel application of H' * qγ)\n\nFor a stacked qγ = (q_{γ,1},\\dots,q_{γ,N}), div_gamma! applies:\n\nH^top q_gamma\n= sum_d leftD_md^top(A_d odot q_gammad) - B_d odot D_md^top(q_gammad)right\n\nThese are intended for solver coupling/KKT augmentation without requiring full assembly.","category":"section"},{"location":"constraints/#Common-limits","page":"Interface Constraints","title":"Common limits","text":"Robin with b=0: value-like condition on xγ\nRobin with a=0: flux-like condition through H'W!(Gxω+Hxγ)\nFlux jump with identical fields/coefficients: residual tends to zero\nScalar jump is independent of interface normal sign","category":"section"},{"location":"boundary-conditions/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary-conditions/#Diffusion-BC-(BoxBC)","page":"Boundary Conditions","title":"Diffusion BC (BoxBC)","text":"Diffusion operators (assembled_ops, kernel_ops) use BoxBC with:\n\nNeumann(0) (default)\nPeriodic\nDirichlet(value)\n\nConstructors:\n\nBoxBC(Val(N), T) default all-Neumann(0)\nBoxBC(lo_tuple, hi_tuple) explicit side-by-side setup\nDirichlet(Ref(value)) for time-varying scalar payloads\nDirichlet(values::Vector) for space-varying full-index payloads\n\nExample:\n\nbc = BoxBC(\n    (Periodic{Float64}(), Neumann(0.0)),\n    (Periodic{Float64}(), Dirichlet(1.0))\n)\nops = assembled_ops(m; bc=bc)","category":"section"},{"location":"boundary-conditions/#Dirichlet-enforcement","page":"Boundary Conditions","title":"Dirichlet enforcement","text":"Default diffusion behavior uses ghost-state elimination (no default row replacement):\n\nboundary values are injected into the effective state used by laplacian_matrix / laplacian!\ndirichlet_rhs / dirichlet_rhs! provide the explicit affine RHS contribution\n\nOptional strong-row utilities are still available:\n\nimpose_dirichlet!(A, rhs, dims, bc) for assembled matrices\napply_dirichlet_rows!(out, x, dims, bc) for residual-row style forms\n\nStable helper API for physics packages:\n\ndirichlet_mask_values(dims, bc) -> mask + current values\ndirichlet_values_vector!(out, dims, bc) -> boundary values with zero interior\ncopy_with_dirichlet!(dest, src, dims, bc) -> state copy with boundary injection\n\nIn the node-padded layout, Dirichlet is imposed on physical boundary layers:\n\nlow side: index 1\nhigh side: index dims[d]-1\n\nThe final padded layer dims[d] is not the physical boundary.","category":"section"},{"location":"boundary-conditions/#Periodic-duplicated-endpoint-convention","page":"Boundary Conditions","title":"Periodic duplicated-endpoint convention","text":"For dims[d] = n:\n\nphysical dofs: 1:(n-1)\nindex n duplicates index 1\nseam wraps as 1 ↔ n-1\npadded row/index n is inactive for difference/average-like stencils\n\nThis convention is used in assembled and kernel operators.","category":"section"},{"location":"boundary-conditions/#Advection-BC-is-separate","page":"Boundary Conditions","title":"Advection BC is separate","text":"Advection does not use BoxBC; it uses AdvBoxBC (see Advection).\n\nThis keeps elliptic BC (Neumann/Dirichlet) separate from hyperbolic BC (Inflow/Outflow/Periodic).","category":"section"},{"location":"boundary-conditions/#Level-set-sign-note","page":"Boundary Conditions","title":"Level-set sign note","text":"If the active domain touches the box boundary (for example an exterior-domain setup in a box), explicit box BC choice is important.","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Index","page":"API Reference","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Full-API","page":"API Reference","title":"Full API","text":"","category":"section"},{"location":"reference/#CartesianOperators.advection_diffusion!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector, KernelAdvectionDiffusionOps{N, T}, NTuple{N, var\"#s32\"} where var\"#s32\"<:(AbstractVector), NTuple{N, var\"#s6\"} where var\"#s6\"<:(AbstractVector), AbstractVector, AbstractVector, KernelWork, KernelWork}} where {N, T}","page":"API Reference","title":"CartesianOperators.advection_diffusion!","text":"advection_diffusion!(out, adops, uω, uγ, Tω, Tγ, ...; scheme=Centered())\n\nCompute κ*Δ(Tω,Tγ) + convection(uω,uγ,Tω,Tγ) in the sign convention used by laplacian! and convection!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CartesianOperators.build_convection_parts-Union{Tuple{T}, Tuple{N}, Tuple{AssembledConvectionOps{N, T}, NTuple{N, var\"#s40\"} where var\"#s40\"<:(AbstractVector), NTuple{N, var\"#s39\"} where var\"#s39\"<:(AbstractVector), AbstractVector, AbstractVector}} where {N, T}","page":"API Reference","title":"CartesianOperators.build_convection_parts","text":"build_convection_parts(cops, uω, uγ, Tω, Tγ)\n\nBuild per-dimension centered advection contributions (bulk and coupling) in assembled form. This uses periodic wrapping when requested by cops.bc_adv; otherwise stencil rows are inactive at the padded boundary.\n\n\n\n\n\n","category":"method"},{"location":"#CartesianOperators.jl","page":"Home","title":"CartesianOperators.jl","text":"CartesianOperators.jl builds Cartesian cut-cell operators from CartesianGeometry.GeometricMoments, matching Penguin algebra and indexing conventions.","category":"section"},{"location":"#Scope","page":"Home","title":"Scope","text":"Assembled sparse operators for diffusion (G, H, Winv)\nMatrix-free kernels for diffusion (dm!, dmT!, gradient!, divergence!, laplacian!)\nCentered/upwind/MUSCL scalar advection (convection!, convection_matrix)\nCoupled advection-diffusion (advection_diffusion!, advection_diffusion_matrix)\nInterface/boundary linear constraints (Robin, flux jump, scalar jump)","category":"section"},{"location":"#Data-layout","page":"Home","title":"Data layout","text":"Given m::GeometricMoments{N,T}:\n\ndims = ntuple(d -> length(m.xyz[d]), N)\nNd = prod(dims)\nvectors (A[d], B[d], W[d], interface_measure) are length Nd\n\nNode-padded convention:\n\nphysical indices per direction are 1:(dims[d]-1)\nindex dims[d] is the duplicated/padded layer","category":"section"},{"location":"#Core-algebra","page":"Home","title":"Core algebra","text":"For bulk/interface unknowns (xω, xγ) and fluxes (qω, qγ):\n\ngradient = Winv * (G*xω + H*xγ)\ndivergence = -(G' + H')*qω + H'*qγ\nlaplacian = -G' * Winv * (G*xω + H*xγ)","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using CartesianGeometry\nusing CartesianOperators\n\nx = collect(range(0.0, 1.0; length=7))\ny = collect(range(0.0, 1.0; length=8))\nphi(x, y, _=0) = sqrt((x - 0.5)^2 + (y - 0.5)^2) - 0.3\nm = geometric_moments(phi, (x, y), Float64, zero; method=:implicitintegration)\n\nopsA = assembled_ops(m)\nopsK = kernel_ops(m)\nwork = KernelWork(opsK)\n\nNd = opsA.Nd\nN = length(opsA.dims)\nxω = randn(Nd)\nxγ = randn(Nd)\n\ngA = zeros(N * Nd)\ngK = similar(gA)\ngradient!(gA, opsA, xω, xγ)\ngradient!(gK, opsK, xω, xγ, work)\n\nmaximum(abs, gA - gK) < 1e-12","category":"section"},{"location":"#Navigation","page":"Home","title":"Navigation","text":"Boundary Conditions\nDiffusion Operators\nAdvection\nAdvection-Diffusion\nConstraints\nAPI Reference","category":"section"},{"location":"advection-diffusion/#Advection-Diffusion","page":"Advection-Diffusion","title":"Advection-Diffusion","text":"CartesianOperators.jl exposes a combined operator:\n\nout = κ * Laplacian(Tω, Tγ) + Convection(uω, uγ, Tω, Tγ; scheme)\n\nwith the same sign convention as laplacian! and convection!.","category":"section"},{"location":"advection-diffusion/#Implemented-equation-(exact-sign)","page":"Advection-Diffusion","title":"Implemented equation (exact sign)","text":"mathcalAmathcalD(T^omegaT^gamma)\n= kappaleft-G^top W^-1(G T^omega + H T^gamma)right\n+ mathrmconvection(u^omegau^gammaT^omegaT^gamma)\n\nSo both assembled and kernel paths compute:\n\ntextttout = kappaDelta_h(T^omegaT^gamma) + textttconvection","category":"section"},{"location":"advection-diffusion/#Constructors","page":"Advection-Diffusion","title":"Constructors","text":"assembled_advection_diffusion_ops(m; bc=nothing, bc_adv=nothing, κ=one(T))\nkernel_advection_diffusion_ops(m; bc=nothing, bc_adv=nothing, κ=one(T))\n\nwhere:\n\nbc is diffusion BoxBC\nbc_adv is advection AdvBoxBC\nκ is a scalar diffusion coefficient","category":"section"},{"location":"advection-diffusion/#API","page":"Advection-Diffusion","title":"API","text":"advection_diffusion_matrix(adops, uω, uγ, Tω, Tγ; scheme=Centered())\nadvection_diffusion!(out, adops, uω, uγ, Tω, Tγ; scheme=Centered())\nadvection_diffusion!(out, adops::KernelAdvectionDiffusionOps, uω, uγ, Tω, Tγ, work_diff, work_adv; scheme=Centered())\n\nKernel path is allocation-free when work buffers are reused.","category":"section"},{"location":"advection-diffusion/#Example","page":"Advection-Diffusion","title":"Example","text":"adA = assembled_advection_diffusion_ops(m; bc=bc, bc_adv=bc_adv, κ=0.7)\nadK = kernel_advection_diffusion_ops(m; bc=bc, bc_adv=bc_adv, κ=0.7)\n\nworkD = KernelWork(adK.diff)\nworkA = KernelWork(adK.adv)\nout = zeros(adK.diff.Nd)\n\nadvection_diffusion!(out, adK, uω, uγ, Tω, Tγ, workD, workA; scheme=Upwind1())","category":"section"},{"location":"advection/#Advection","page":"Advection","title":"Advection","text":"The implemented convection operator is the quantity returned by convection! / convection_matrix. Its sign is exactly the one in code and tests (T^{n+1} = T^n + dt * convection(T^n)).\n\nScalar advection is available in assembled and matrix-free forms.","category":"section"},{"location":"advection/#Constructors","page":"Advection","title":"Constructors","text":"assembled_convection_ops(m; bc_adv=nothing) -> AssembledConvectionOps\nkernel_convection_ops(m; bc_adv=nothing) -> KernelConvectionOps\n\nbc_adv=nothing defaults to outflow on every side.","category":"section"},{"location":"advection/#Advection-BC-(AdvBoxBC)","page":"Advection","title":"Advection BC (AdvBoxBC)","text":"AdvOutflow (default)\nAdvPeriodic\nAdvInflow(value)\n\nExample:\n\nbc_adv = AdvBoxBC(\n    (AdvPeriodic{Float64}(), AdvInflow(1.0)),\n    (AdvPeriodic{Float64}(), AdvOutflow{Float64}())\n)\n\ncops = kernel_convection_ops(m; bc_adv=bc_adv)\n\nNotes:\n\nAdvInflow(value) is used where upwind/MUSCL need ghost states.\nCentered() does not consume inflow ghost values.","category":"section"},{"location":"advection/#Schemes","page":"Advection","title":"Schemes","text":"Types:\n\nCentered()\nUpwind1()\nMUSCL(Minmod())\nMUSCL(MC())\nMUSCL(VanLeer())\n\nSupport matrix:\n\nassembled convection_matrix: Centered, Upwind1\nkernel convection!: Centered, Upwind1, all MUSCL variants","category":"section"},{"location":"advection/#Implemented-equations-(exact-signs)","page":"Advection","title":"Implemented equations (exact signs)","text":"For each direction d, define:\n\nT_mathrmmix = fracT^omega + T^gamma2\n\nCentered bulk term:\n\nmathrmbulk_d^mathrmcen\n= D_pdleft((A_d odot u^omega_d)odot (S_mdT^omega)right)\n\nUpwind1 bulk term:\n\na_d = A_d odot u^omega_dquad\nF_d(i)=\nbegincases\na_d(i)T^omega(i)  a_d(i)ge 0\na_d(i)T^omega_mathrmright(i)  a_d(i)0\nendcases\nquad\nmathrmbulk_d^mathrmup = D_pdF_d\n\nCoupling term (shared across schemes):\n\nK_1d=D_pdleft((S_mdB_d-A_d)odot u^gamma_dright)qquad\nK_2d=S_mdleft(D_pd(B_dodot u^gamma_d)right)\n\nmathrmcoup_d=(K_1d-K_2d)odot T_mathrmmix\n\nTotal convection returned by the API:\n\nmathrmconvection = sum_d left(mathrmbulk_d + mathrmcoup_dright)\n\nThere is no extra global minus sign applied by convection!.","category":"section"},{"location":"advection/#API","page":"Advection","title":"API","text":"convection_matrix(cops, uω, uγ, Tω, Tγ; scheme=Centered())\nconvection!(out, cops, uω, uγ, Tω, Tγ, work; scheme=Centered())\n\nWhere:\n\nuω, uγ are NTuple{N,Vector} velocities\nTω, Tγ are scalar vectors length Nd\n\nThe interface coupling term currently matches the centered derivation and is shared across schemes.","category":"section"}]
}
